use std::str::FromStr;
use lalrpop_util::{ParseError, ErrorRecovery};
use crate::lexer::{Token, ParserError};
use crate::ast::*;

grammar<'input, 'err>(input: &'input str, errs: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParserError>>);

pub Program: Vec<ProgramPart> = {
    ProgramPart+ => <>
};

ProgramPart: ProgramPart = {
    "mod" <name:Identifier> "{" <p:Program> "}" => ProgramPart::Module(name, p),
    StructDefinition => ProgramPart::StructDefinition(<>),
};

StructDefinition: StructDefinition= {
    <b:"builtin"?> "struct" <name:Identifier> <bounds:(":" <Type>)?> "{" <members:Comma<MemberVariable>> "}" => StructDefinition{name, builtin: b.is_some(), bounds, members}, 
};

MemberVariable: MemberVariable = {
    <name:Identifier> ":" <ty:Type> => MemberVariable{name, ty}
};

Identifier: Identifier = {
    <l:@L> <n:TokenIdentifier> <r:@R> => Identifier::new(l, r, n.to_string())
};

Stmt: Stmt = {
    <l:@L> <e:Expr> <semi:(<@L>";"<@R>)?> <r:@R> => {
        let val = if let Some((l, r)) = semi {
            StmtKind::Semi(Box::new(e), Span{l,r})
        } else {
            StmtKind::Expr(Box::new(e))
        };

        Stmt::new(l, r, val)
    }
};

Spanned<T>: Spanned<T> = {
    <l:@L> <val:T> <r:@R> => Spanned::new(l, r, val),
}

BinOpExpr<Op, Next>: Expr = {
    <l:@L> <lhs:BinOpExpr<Op, Next>> <op:Spanned<Op>> <rhs:Next> <r:@R> => Expr::new(l, r, ExprKind::BinOp(op, bx(lhs), bx(rhs))),
    Next,
};

pub Expr: Expr = {
    Expr6
};

Expr6: Expr = {
    <lo:@L> <lhs:Expr5> <l:@L> "=" <r:@R> <rhs:Expr6> <ro:@R> => Expr::new(lo, ro, ExprKind::Assign(Span{l,r}, bx(lhs), bx(rhs))),
    <l:@L> <lhs:Expr5> <op:Spanned<OpAssign>> <rhs:Expr6> <r:@R> => Expr::new(l, r, ExprKind::AssignOp(op, bx(lhs), bx(rhs))),
    Expr5,
};
OpAssign: BinOpKind = {
    "+=" => BinOpKind::Add,
    "-=" => BinOpKind::Sub,
    "*=" => BinOpKind::Mul,
    "/=" => BinOpKind::Div,
    "%=" => BinOpKind::Rem,
    "&=" => BinOpKind::Rem,
    "|=" => BinOpKind::Rem,
};

Expr5 = BinOpExpr<Op5, Expr4>;
Op5: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Sub,
};

Expr4 = BinOpExpr<Op4, Expr0>;
Op4: BinOpKind = {
    "*" => BinOpKind::Mul,
    "/" => BinOpKind::Div,
    "%" => BinOpKind::Rem,
};

Expr0: Expr = {
    <l:@L> <lit:Lit> <r:@R> => Expr::new(l, r, ExprKind::Lit(lit)),
    <l:@L> <ident:Identifier> <r:@R> => Expr::new(l, r, ExprKind::Variable(ident)),
    <l:@L> "(" <exprs:Many1<",", Expr>> ")" <r:@R> => {
        if exprs.len() == 1 {
            let mut exprs = exprs;
            exprs.remove(0)
        } else {
            Expr::new(l, r, ExprKind::Tuple(exprs))
        }
    },
    <l:@L> <err:!> <r:@R> => { errs.push(err); Expr::new(l, r, ExprKind::Err) }
};

Lit: LitKind = {
    "true" => LitKind::Bool(true),
    "false" => LitKind::Bool(false),
    <s:TokenString> => LitKind::String(s.to_string()),
    <l:@L> <tok:TokenInt> <r:@R> => {
        let s: String = tok.chars().filter(|v| *v != '_').collect();
        match i32::from_str(&s) {
            Ok(i) => LitKind::Int(i),
            Err(_) => {
                errs.push(ErrorRecovery {
                    error: ParseError::User{ 
                        error: ParserError::IntTooBig(l, r)
                    },
                    dropped_tokens: vec![(l, Token::IntLiteral(tok.clone()), r)]
                });

                LitKind::Err
            }
        }
    }
};

Type: Type = {
    <l:@L> "bool" <r:@R> => Type::new(l, r, TypeKind::Bool),
    <l:@L> "string" <r:@R> => Type::new(l, r, TypeKind::String),
    <l:@L> "int" <r:@R> => Type::new(l, r, TypeKind::Int),
    <l:@L> "(" ")" <r:@R> => Type::new(l, r, TypeKind::Unit),
    <l:@L> <ty:ComplexType> <r:@R> => Type::new(l, r, TypeKind::Complex(ty)),
};

ComplexType: ComplexType = {
    <l:@L> <ty:Many1<"+", ComplexType1>> <r:@R> => {
        if ty.len() == 1 {
            let mut ty = ty;
            ty.remove(0)
        } else {
            ComplexType::new(l, r, ComplexTypeKind::Compound(ty))
        }
    }
};

ComplexType1: ComplexType = {
    <l:@L> "^" <ty:ComplexType0> <r:@R> => ComplexType::new(l, r, ComplexTypeKind::Above(Box::new(ty))),
    <l:@L> "!" <ty:ComplexType0> <r:@R> => ComplexType::new(l, r, ComplexTypeKind::Not(Box::new(ty))),
    ComplexType0 => <>
};

ComplexType0: ComplexType = {
    <l:@L> <name:Identifier> <r:@R> => ComplexType::new(l, r, ComplexTypeKind::Base(name, ComplexReferent::Infer)),
    <l:@L> "(" <ty:ComplexType> ")" <r:@R> => ty,
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Many1<SEP, T>: Vec<T> = {
    <e:T> <v:(SEP <T>)*> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

Many2<SEP, T>: Vec<T> = {
    <e:T> <v:(SEP <T>)+> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

extern {
    type Location = usize;
    type Error = ParserError;

    enum Token<'input> {
        TokenIdentifier => Token::Identifier(<&'input str>),
        TokenString => Token::StringLiteral(<&'input str>),
        TokenInt => Token::IntLiteral(<&'input str>),
        "true" => Token::True,
        "false" => Token::False,
        "const" => Token::Const,
        "do" => Token::Do,
        "while" => Token::While,
        "if" => Token::If,
        "else" => Token::Else,
        "string" => Token::String,
        "bool" => Token::Bool,
        "int" => Token::Int,
        "fn" => Token::Fn,
        "let" => Token::Let,
        "return" => Token::Return,
        "mod" => Token::Mod,
        "struct" => Token::Struct,
        "trait" => Token::Trait,
        "enum" => Token::Enum,
        "builtin" => Token::Builtin,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        "." => Token::Dot,
        ":" => Token::Colon,
        "." => Token::Dot,
        "!" => Token::Exclamation,
        "^" => Token::Caret,
        "{" => Token::OpenBlock,
        "}" => Token::CloseBlock,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "#" => Token::Hash,
        "&" => Token::And,
        "|" => Token::Or,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Rem,
        "==" => Token::Eq,
        "!=" => Token::Ne,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "=" => Token::Assign,
        "+=" => Token::AddAssign,
        "-=" => Token::SubAssign,
        "*=" => Token::MulAssign,
        "/=" => Token::DivAssign,
        "%=" => Token::RemAssign,
        "|=" => Token::OrAssign,
        "&=" => Token::AndAssign,
    }
}