use std::str::FromStr;
use crate::lexer::{Token, LexicalError};
use crate::ast::*;

grammar<'input>(input: &'input str);

pub Program: Vec<ProgramPart> = {
    ProgramPart+ => <>
}

ProgramPart: ProgramPart = {
    StructDefinition => ProgramPart::StructDefinition(<>),
}

StructDefinition: StructDefinition= {
    "struct" <name:Identifier> <bounds:(":" <Type>)?> "{" <members:Comma<MemberVariable>> "}" => StructDefinition{name, bounds, members}, 
}

MemberVariable: MemberVariable = {
    <name:Identifier> ":" <ty:Type> => MemberVariable{name, ty}
}

Identifier: Identifier = {
    <l:@L> <n:TokenIdentifier> <r:@R> => Identifier{span: Span{r, l}, name: n.to_string()}
}

pub Type: Type = {
    <l:@L> "bool" <r:@R> => Type{span: Span{l,r}, kind: TypeKind::Bool},
    <l:@L> "string" <r:@R> => Type{span: Span{l,r}, kind: TypeKind::String},
    <l:@L> "int" <r:@R> => Type{span: Span{l,r}, kind: TypeKind::Int},
    <l:@L> "(" ")" <r:@R> => Type{span: Span{l,r}, kind: TypeKind::Unit},
    <l:@L> <ty:ComplexType> <r:@R> => Type{span: Span{l,r}, kind: TypeKind::Complex(ty)},
};

ComplexType: ComplexType = {
    <l:@L> <ty:Many1<"+", ComplexType1>> <r:@R> => {
        if ty.len() == 1 {
            let mut ty = ty;
            ty.remove(0)
        } else {
            ComplexType{span: Span{l,r}, kind: ComplexTypeKind::Compound(ty)}
        }
    }
}

ComplexType1: ComplexType = {
    <l:@L> "^" <ty:ComplexType0> <r:@R> => ComplexType{span: Span{l,r}, kind: ComplexTypeKind::Above(Box::new(ty))},
    <l:@L> "!" <ty:ComplexType0> <r:@R> => ComplexType{span: Span{l,r}, kind: ComplexTypeKind::Not(Box::new(ty))},
    ComplexType0 => <>
};

ComplexType0: ComplexType = {
    <l:@L> <name:Identifier> <r:@R> => ComplexType{span: Span{l,r}, kind: ComplexTypeKind::Base(name, ComplexReferent::Infer)},
    <l:@L> "(" <ty:ComplexType> ")" <r:@R> => ty,
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Many1<SEP, T>: Vec<T> = {
    <e:T> <v:(SEP <T>)*> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

Many2<SEP, T>: Vec<T> = {
    <e:T> <v:(SEP <T>)+> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        TokenIdentifier => Token::Identifier(<&'input str>),
        TokenString => Token::StringLiteral(<&'input str>),
        "true" => Token::True,
        "false" => Token::False,
        "const" => Token::Const,
        "do" => Token::Do,
        "while" => Token::While,
        "if" => Token::If,
        "else" => Token::Else,
        "string" => Token::String,
        "bool" => Token::Bool,
        "int" => Token::Int,
        "fn" => Token::Fn,
        "let" => Token::Let,
        "return" => Token::Return,
        "struct" => Token::Struct,
        "trait" => Token::Trait,
        "enum" => Token::Enum,
        "," => Token::Comma,
        ":" => Token::Colon,
        "." => Token::Dot,
        "!" => Token::Exclamation,
        "^" => Token::Caret,
        "+" => Token::Plus,
        "{" => Token::OpenBlock,
        "}" => Token::CloseBlock,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "#" => Token::Hash,
    }
}